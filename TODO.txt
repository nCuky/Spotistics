3. Multi-Threading - when fetching large quantity of data, optimize performance so that it fetches using multi processing.


* column function - from all listen data, for every combination of Artist+Track+Album, find how many instances exist.

---Audio Features---
* All Zappa songs - columns graph by key


* Ver.1: Always search for the "original" track ID, saved in 'linked_from' object of a Track.
See more info here: https://developer.spotify.com/documentation/general/guides/track-relinking-guide/
  In short, need to get the relinked_id for every track, and then put alongside the "track_id" already there (considered the "original_id").
* Ver.2: This is difficult, as no TrackID can be considered "the original". The relinked ID is relative to market and there is no single
market that I can depend on, which is considered "the absolute" market.
Also, it is not 100% guaranteed that there will even be a 'LinkedTrack' for a given track, even if it reasonably "should" be.
Instead, I use the combination of "Artist name + Album name + Track Title", known as "TrackCombo".
* Ver.3: Compromise and final decision:
0. *** IMPORTANT NOTICE *** The philosophical question of "What is considered a Song" is a very complicated question
which I can't and won't solve right now.
1. For every "TrackCombo", collect all distinct track_id values and put them in an Array for that TrackCombo.
2. Create a new column in the 'all_tracks' dataframe, named 'unified_track_id'



----done---
* make sure the API returns ALL items and not only the first 100 - send 'offset' parameter to the API function calls
rewrite all functions so that they use this new logic

* GUI - 'get audio features' button -> show graph

-cancelled- example playlist, 746 songs: 'ProgPsy Rock and Neo Psy Rock'


